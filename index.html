<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Avalon</title>
  <style>
    body { font-family: 'Inter', -apple-system, system-ui, sans-serif; margin: 0; background: #0d1429; color: #e8edf7; }
    .wrap { max-width: 820px; margin: 0 auto; padding: 18px 16px 32px; }
    .card { background: #0f1b33; border-radius: 16px; padding: 18px; box-shadow: 0 18px 42px rgba(0,0,0,.25); border: 1px solid rgba(255,255,255,0.06); margin: 12px 0; }
    h1 { font-size: 24px; margin: 4px 0; letter-spacing: -0.4px; }
    h2 { font-size: 18px; margin: 0 0 12px; color: #f3f6ff; letter-spacing: -0.2px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    label { font-size: 13px; color: #9aa6c4; display:block; margin: 8px 0 4px; letter-spacing: 0.2px; }
    input[type="number"], input[type="text"], select {
      width: 100%; padding: 11px 12px; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; font-size: 15px;
      background: #0b1425; color: #e8edf7; transition: border .2s, box-shadow .2s;
    }
    input:focus, select:focus { outline: none; border-color: #7c5dfa; box-shadow: 0 0 0 2px rgba(124,93,250,0.25); }
    button {
      border: 0; padding: 12px 14px; border-radius: 14px; font-size: 16px; cursor: pointer;
      background: linear-gradient(135deg, #7c5dfa 0%, #5ad1ff 100%); color: #fff; font-weight: 700; letter-spacing: 0.2px;
      transition: transform .15s ease, box-shadow .2s ease, opacity .2s; box-shadow: 0 12px 32px rgba(124,93,250,0.35);
    }
    button.secondary { background: #1b2539; color: #e8edf7; box-shadow: none; }
    button.danger { background: #e84b5b; box-shadow: 0 12px 28px rgba(232,75,91,0.35); }
    button:disabled { opacity: .55; cursor: not-allowed; transform: none; box-shadow: none; }
    button:not(:disabled):hover { transform: translateY(-1px); }
    .pill { display:inline-block; padding: 6px 10px; border-radius: 999px; background: rgba(124,93,250,0.16); margin: 6px 6px 0 0; font-size: 13px; color: #e8edf7; border: 1px solid rgba(124,93,250,0.35); }
    .muted { color:#9aa6c4; font-size: 13px; }
    .leaderLine { display:block; font-size:16px; font-weight:700; color:#f3f6ff; margin-top:4px; }
    .center { text-align:center; }
    .big { font-size: 22px; font-weight: 700; }
    .questGrid { display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
    .questBox { padding: 12px; border-radius: 14px; background:#0f192c; text-align:center; border: 1px solid rgba(255,255,255,0.06); color: #e8edf7; }
    .good { background: rgba(157,227,177,0.18); border-color: rgba(157,227,177,0.55); color: #d8ffe7; }
    .evil { background: rgba(244,183,183,0.18); border-color: rgba(244,183,183,0.55); color: #ffe3e3; }
    .hidden { display:none; }
    .teamPicker { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 2px; margin-top:4px; }
    .teamPicker .checkbox { margin: 2px 0; gap: 6px; padding: 4px 6px; font-size: 14px; background: #0f192c; border: 1px solid rgba(255,255,255,0.05); border-radius: 10px; color: #e8edf7; }
    .teamPicker .checkbox input { width: 16px; height: 16px; }
    #voteSummary, #missionPrompt { font-weight: 600; }
    .revealContainer { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; justify-content:center; }
    .revealCard {
      width: 64px; height: 82px; border-radius: 12px; background:#16233b; color:#dfe7ff;
      display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:0.5px;
      opacity:0; transform: translateY(12px) scale(.96); transition: all .3s ease; border: 1px solid rgba(255,255,255,0.08);
    }
    .revealCard.show { opacity:1; transform: translateY(0) scale(1); }
    .revealCard.pass { background:#163127; color:#d4ffe8; border-color: rgba(157,227,177,0.55); }
    .revealCard.fail { background:#332126; color:#ffd7d7; border-color: rgba(244,183,183,0.6); }
    .checkbox { display:flex; align-items:center; gap: 8px; margin: 6px 0; color: #e8edf7; }
    .checkbox input { width: 18px; height: 18px; }
    /* Compact overrides for proposal picker */
    .teamPicker .checkbox { margin: 1px 0; gap: 4px; padding: 2px 3px; font-size: 14px; }
    .teamPicker .checkbox input { width: 14px; height: 14px; }
    .divider { height:1px; background: rgba(255,255,255,0.08); margin: 14px 0; }
    .roleCard { border-radius: 18px; padding: 18px; background: linear-gradient(135deg, #1f2937 0%, #0e1423 100%); color:#fff; border: 1px solid rgba(255,255,255,0.08); }
    .roleName { font-size: 26px; font-weight: 800; margin: 4px 0 8px; }
    .roleTeam { font-size: 14px; opacity:.9; margin-bottom: 10px; }
    .roleInfo { background: rgba(255,255,255,.08); padding: 12px; border-radius: 14px; font-size: 14px; line-height:1.35; }
    .topBar { display:flex; justify-content:space-between; align-items:center; gap: 10px; }
    .linkbtn { background: transparent; color:#b6c4ff; padding: 0; text-decoration: underline; font-size: 14px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topBar">
    <h1>Avalon</h1>
    <button class="linkbtn" id="btnResetAll" title="Reset everything">Reset</button>
  </div>
  <!-- <div class="muted">Pass-the-phone role reveal + 5 quest tracker.</div> -->

  <!-- SETUP -->
  <div class="card" id="setupCard">
    <h2>1) Setup</h2>
    <div class="row">
      <div style="flex:1; min-width: 160px;">
        <label>Number of players (5–14)</label>
        <input id="numPlayers" type="number" min="5" max="14" value="7" />
      </div>
      <div style="flex:2; min-width: 240px;">
        <label>Player names (optional, comma separated)</label>
        <input id="playerNames" type="text" placeholder="Alex, Sam, ... (or leave blank)" />
      </div>
    </div>

    <div class="divider"></div>
    <div>
      <div class="muted">Roles (defaults are common). “Evil count” auto-scales by player count.</div>

      <div class="checkbox"><input id="roleMerlin" type="checkbox" checked><label for="roleMerlin">Merlin (Good)</label></div>
      <div class="checkbox"><input id="rolePercival" type="checkbox" checked><label for="rolePercival">Percival (Good)</label></div>

      <div class="checkbox"><input id="roleAssassin" type="checkbox" checked><label for="roleAssassin">Assassin (Evil)</label></div>
      <div class="checkbox"><input id="roleMorgana" type="checkbox"><label for="roleMorgana">Morgana (Evil)</label></div>
      <div class="checkbox"><input id="roleOberon" type="checkbox"><label for="roleOberon">Oberon (Evil, hidden from evil)</label></div>

      <div class="checkbox"><input id="roleMordred" type="checkbox"><label for="roleMordred">Mordred (Evil, hidden from Merlin)</label></div>

      <div class="divider"></div>
      <button id="btnStart">Start game</button>
      <div class="muted" id="setupHint" style="margin-top:10px;"></div>
    </div>
  </div>

  <!-- ROLE REVEAL -->
  <div class="card hidden" id="revealCard">
    <h2>2) Role reveal (pass the phone)</h2>
    <div class="center muted" id="revealStep"></div>

    <div class="card roleCard hidden" id="roleDisplay">
      <div class="roleName" id="roleName"></div>
      <div class="roleTeam" id="roleTeam"></div>
      <div class="roleInfo" id="roleInfo"></div>
    </div>

    <div class="center" style="margin-top:12px;">
      <button id="btnShowRole" class="secondary">Show role</button>
      <button id="btnHideRole" class="secondary hidden">Hide</button>
      <button id="btnNextPlayer" disabled>Next player</button>
    </div>
  </div>

  <!-- GAME TRACKER -->
  <div class="card hidden" id="gameCard">
    <h2>3) Quest tracker</h2>

    <div class="questGrid" id="questGrid"></div>

    <div class="divider"></div>
    <div id="proposalArea">
      <div id="proposalStatus" class="muted"></div>
      <div id="teamSizeText" class="muted"></div>
      <div id="teamPicker" class="teamPicker"></div>
      <div class="muted" id="teamPickHint" style="margin-top:4px;"></div>
      <div class="row" style="margin-top:10px;">
        <button id="btnSubmitProposal" class="secondary" style="flex:1;">Submit proposal</button>
      </div>
    </div>

    <div id="voteArea" class="hidden" style="margin-top:12px;">
      <div id="voteSummary"></div>
      <div class="row" style="margin-top:8px;">
        <button id="btnVoteApprove" class="secondary" style="flex:1;">Proposal approved</button>
        <button id="btnVoteReject" class="secondary danger" style="flex:1;">Proposal rejected</button>
      </div>
    </div>

  <div id="missionArea" class="hidden" style="margin-top:12px;">
    <div id="missionPrompt"></div>
    <div class="muted" id="missionFailRule" style="margin-top:4px;"></div>
    <div class="row" style="margin-top:8px;">
      <button id="btnCardPass" class="secondary" style="flex:1;">PASS</button>
      <button id="btnCardFail" class="danger" style="flex:1;">FAIL</button>
    </div>
  </div>
  <div id="missionRevealAction" class="hidden" style="margin-top:10px;">
    <button id="btnShowReveal" class="secondary" style="width:100%;">Show the results</button>
  </div>
  <div id="missionRevealArea" class="hidden revealOverlay">
    <div class="revealPanel">
      <div id="missionRevealTitle" class="muted" style="font-weight:700;"></div>
      <div id="missionRevealContainer" class="revealContainer"></div>
      <div class="muted" id="missionRevealNote" style="margin-top:4px;"></div>
    </div>
  </div>

    <div class="divider"></div>
    <div class="center">
      <div class="big" id="statusText">Quest 1 — not decided</div>
      <div class="muted" id="scoreText">Good 0 • Evil 0</div>
    </div>

    <div class="divider"></div>
    <div id="endgameArea" class="hidden">
      <div class="card">
        <div class="big center" id="endgameText"></div>
        <div class="muted center" id="endgameSub"></div>

        <div class="divider"></div>
        <div id="assassinArea" class="hidden">
          <div class="muted">Assassin phase (optional): If Good won 3 quests, Assassin can guess Merlin.</div>
          <label>Who is Merlin?</label>
          <select id="assassinPick"></select>
          <div style="margin-top:10px;" class="center">
            <button id="btnAssassinConfirm" class="danger">Confirm assassination</button>
          </div>
        </div>
      </div>
    </div>

      <div class="divider"></div>
      <button id="btnShowAllRoles" class="secondary hidden">Show all roles (host view)</button>
      <div id="allRoles" class="hidden" style="margin-top:10px;"></div>
  </div>
</div>

<script>
  // ---------- Utilities ----------
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function evilCountFor(n) {
    // Common Avalon scaling:
    // 5-6 => 2 evil, 7-9 => 3 evil, 10-12 => 4 evil, 13-14 => 5 evil
    if (n <= 6) return 2;
    if (n <= 9) return 3;
    if (n <= 12) return 4;
    return 5;
  }

  // Quest team sizes (standard Avalon, extended 11-14):
  // 5: 2,3,2,3,3
  // 6: 2,3,4,3,4
  // 7: 2,3,3,4,4
  // 8: 3,4,4,5,5
  // 9: 3,4,4,5,5
  // 10:3,4,4,5,5
  // 11:4,5,5,6,6
  // 12:4,5,5,6,6
  // 13:4,5,6,7,7
  // 14:5,6,6,7,7
  const teamSizes = {
    5:[2,3,2,3,3],
    6:[2,3,4,3,4],
    7:[2,3,3,4,4],
    8:[3,4,4,5,5],
    9:[3,4,4,5,5],
    10:[3,4,4,5,5],
    11:[4,5,5,6,6],
    12:[4,5,5,6,6],
    13:[4,5,6,7,7],
    14:[5,6,6,7,7]
  };

  // Rule: On 7+ players, Quest 4 needs 2 fails to fail (some versions use 7+ only)
  function questNeedsTwoFails(nPlayers, questIndex) {
    return (nPlayers >= 7 && questIndex === 3); // questIndex 3 => 4th quest
  }

  // ---------- State ----------
  const state = {
    started: false,
    nPlayers: 7,
    players: [],
    roles: [],         // list of role objects assigned per player index
    revealIndex: 0,
    questResults: [null,null,null,null,null], // true=success, false=fail
    currentQuest: 0,
    goodScore: 0,
    evilScore: 0,
    ended: false,
    assassinResolved: false,
    proposalAttempt: 1,
    currentProposal: [],
    missionStepIndex: 0,
    missionFailCount: 0,
    missionCards: [],
    missionRevealReady: false,
    questPhase: 'proposal', // 'proposal' | 'vote' | 'mission'
    currentLeaderIndex: null,
    usedApprovedLeaders: [],
    currentQuestLeaders: []
  };

  // ---------- Elements ----------
  const setupCard = document.getElementById('setupCard');
  const revealCard = document.getElementById('revealCard');
  const gameCard = document.getElementById('gameCard');

  const numPlayersEl = document.getElementById('numPlayers');
  const playerNamesEl = document.getElementById('playerNames');
  const setupHint = document.getElementById('setupHint');

  const btnStart = document.getElementById('btnStart');
  const btnResetAll = document.getElementById('btnResetAll');

  const revealStep = document.getElementById('revealStep');
  const roleDisplay = document.getElementById('roleDisplay');
  const roleName = document.getElementById('roleName');
  const roleTeam = document.getElementById('roleTeam');
  const roleInfo = document.getElementById('roleInfo');
  const btnShowRole = document.getElementById('btnShowRole');
  const btnHideRole = document.getElementById('btnHideRole');
  const btnNextPlayer = document.getElementById('btnNextPlayer');

  const questGrid = document.getElementById('questGrid');
  const proposalArea = document.getElementById('proposalArea');
  const voteArea = document.getElementById('voteArea');
  const missionArea = document.getElementById('missionArea');
  const proposalStatus = document.getElementById('proposalStatus');
  const teamSizeText = document.getElementById('teamSizeText');
  const teamPicker = document.getElementById('teamPicker');
  const teamPickHint = document.getElementById('teamPickHint');
  const voteSummary = document.getElementById('voteSummary');
  const missionPrompt = document.getElementById('missionPrompt');
  const missionFailRule = document.getElementById('missionFailRule');
  const missionRevealAction = document.getElementById('missionRevealAction');
  const btnShowReveal = document.getElementById('btnShowReveal');
  const missionRevealArea = document.getElementById('missionRevealArea');
  const missionRevealTitle = document.getElementById('missionRevealTitle');
  const missionRevealContainer = document.getElementById('missionRevealContainer');
  const missionRevealNote = document.getElementById('missionRevealNote');
  const btnSubmitProposal = document.getElementById('btnSubmitProposal');
  const btnVoteApprove = document.getElementById('btnVoteApprove');
  const btnVoteReject = document.getElementById('btnVoteReject');
  const btnCardPass = document.getElementById('btnCardPass');
  const btnCardFail = document.getElementById('btnCardFail');
  const statusText = document.getElementById('statusText');
  const scoreText = document.getElementById('scoreText');

  const endgameArea = document.getElementById('endgameArea');
  const endgameText = document.getElementById('endgameText');
  const endgameSub = document.getElementById('endgameSub');

  const assassinArea = document.getElementById('assassinArea');
  const assassinPick = document.getElementById('assassinPick');
  const btnAssassinConfirm = document.getElementById('btnAssassinConfirm');

  const btnShowAllRoles = document.getElementById('btnShowAllRoles');
  const allRoles = document.getElementById('allRoles');

  // role checkboxes
  const roleMerlin = document.getElementById('roleMerlin');
  const rolePercival = document.getElementById('rolePercival');
  const roleAssassin = document.getElementById('roleAssassin');
  const roleMorgana = document.getElementById('roleMorgana');
  const roleOberon = document.getElementById('roleOberon');
  const roleMordred = document.getElementById('roleMordred');

  function autoSelectRecommendedRoles(n) {
    // Recommend Morgana automatically, but leave room for user overrides. Default for 6-player games: neither Percival nor Morgana pre-selected.
    const percivalManual = rolePercival.dataset.manual === 'true';
    const morganaManual = roleMorgana.dataset.manual === 'true';
    const merlinManual = roleMerlin.dataset.manual === 'true';
    const assassinManual = roleAssassin.dataset.manual === 'true';
    const oberonManual = roleOberon.dataset.manual === 'true';
    const mordredManual = roleMordred.dataset.manual === 'true';

    // Recommended defaults by player count:
    // 10: all specials on
    // 11-12: Merlin, Percival, Assassin, Morgana, Mordred, Oberon
    // 13-14: same as 11-12 (evil minion auto-fills the 5th evil)
    if (n === 10) {
      if (!merlinManual) roleMerlin.checked = true;
      if (!percivalManual) rolePercival.checked = true;
      if (!assassinManual) roleAssassin.checked = true;
      if (!morganaManual) roleMorgana.checked = true;
      if (!oberonManual) roleOberon.checked = true;
      if (!mordredManual) roleMordred.checked = true;
    } else if (n >= 11 && n <= 14) {
      if (!merlinManual) roleMerlin.checked = true;
      if (!percivalManual) rolePercival.checked = true;
      if (!assassinManual) roleAssassin.checked = true;
      if (!morganaManual) roleMorgana.checked = true;
      if (!mordredManual) roleMordred.checked = true;
      if (!oberonManual) roleOberon.checked = true;
    }

    if (n === 6 && !percivalManual && !morganaManual) {
      rolePercival.checked = false;
      roleMorgana.checked = false;
    }

    const recommendMorgana = (n >= 7) || (n === 6 && rolePercival.checked);
    if (!morganaManual && recommendMorgana) {
      roleMorgana.checked = true;
    }
    const recommendMordred = (n >= 7);
    if (!mordredManual && recommendMordred) {
      roleMordred.checked = true;
    }

    // Keep Percival and Morgana paired whenever either is selected.
    if (rolePercival.checked && !roleMorgana.checked) roleMorgana.checked = true;
    if (roleMorgana.checked && !rolePercival.checked) rolePercival.checked = true;
  }

  function enforceOberonLimit(n) {
    const allowed = n >= 10;
    roleOberon.disabled = !allowed;
    if (!allowed && roleOberon.checked) {
      roleOberon.checked = false;
    }
  }

  function updateSetupHint() {
    const n = clampPlayers(Number(numPlayersEl.value));
    autoSelectRecommendedRoles(n);
    enforceOberonLimit(n);
    const evilN = evilCountFor(n);

    const selected = getSelectedRoleFlags();
    const fixedEvil = selected.evilSpecialCount(); // assassin + morgana + oberon + mordred
    const fixedGood = selected.goodSpecialCount(); // merlin + percival

    setupHint.textContent =
      `Players: ${n}. Evil should be ${evilN}. Selected special roles: Good ${fixedGood}, Evil ${fixedEvil}. The rest will be plain Servants/Minions automatically.`;
  }

  function clampPlayers(n) {
    if (!Number.isFinite(n)) return 7;
    return Math.max(5, Math.min(14, Math.floor(n)));
  }

  function getSelectedRoleFlags() {
    return {
      merlin: roleMerlin.checked,
      percival: rolePercival.checked,
      assassin: roleAssassin.checked,
      morgana: roleMorgana.checked,
      oberon: roleOberon.checked,
      mordred: roleMordred.checked,
      evilSpecialCount() {
        return (this.assassin?1:0) + (this.morgana?1:0) + (this.oberon?1:0) + (this.mordred?1:0);
      },
      goodSpecialCount() {
        return (this.merlin?1:0) + (this.percival?1:0);
      }
    };
  }

  function parsePlayers(n) {
    const raw = playerNamesEl.value.trim();
    let names = [];
    if (raw.length > 0) {
      names = raw.split(',').map(s => s.trim()).filter(Boolean);
    }
    // Fill or trim to n
    const players = [];
    for (let i = 0; i < n; i++) {
      players.push(names[i] || `Player ${i+1}`);
    }
    return players;
  }

  function buildRoles(n, flags) {
    const evilN = evilCountFor(n);

    // Build evil roles
    const evil = [];
    if (flags.assassin) evil.push(makeRole('Assassin', 'Evil', 'You are Evil. At the end, if Good wins 3 quests, you may guess Merlin.'));
    if (flags.morgana) evil.push(makeRole('Morgana', 'Evil', 'You appear as Merlin to Percival.'));
    if (flags.oberon) evil.push(makeRole('Oberon', 'Evil', 'You are Evil, but you do NOT know the other Evil players, and they do not know you.'));
    if (flags.mordred) evil.push(makeRole('Mordred', 'Evil', 'Merlin does NOT see you as Evil.'));

    // Ensure at least one evil exists (classic requires evil minions)
    while (evil.length < evilN) {
      evil.push(makeRole('Evil Without Special Role', 'Evil', 'You are Evil.'));
    }
    // If too many selected, trim (keep Assassin first if exists)
    if (evil.length > evilN) {
      // Keep assassin if present
      const assassinIdx = evil.findIndex(r => r.name === 'Assassin');
      const kept = [];
      if (assassinIdx >= 0) kept.push(evil[assassinIdx]);
      for (let i = 0; i < evil.length && kept.length < evilN; i++) {
        if (i === assassinIdx) continue;
        kept.push(evil[i]);
      }
      evil.length = 0;
      evil.push(...kept);
    }

    // Build good roles
    const good = [];
    if (flags.merlin) good.push(makeRole('Merlin', 'Good', 'You know most Evil players (except Mordred). Be subtle.'));
    if (flags.percival) good.push(makeRole('Percival', 'Good', 'You see two players below: one is Merlin, and the other is Morgana (if Morgana is in the game). \nFigure out which is Merlin and protect him/her so the Assassin cannot identify him/her.'));
    while (good.length < (n - evilN)) {
      good.push(makeRole('Loyal Citizen', 'Good', 'You are Good.'));
    }

    const all = evil.concat(good);
    shuffle(all);
    return all;
  }

  function makeRole(name, team, blurb) {
    return { name, team, blurb };
  }

  function buildKnowledgeText(playerIndex) {
    const me = state.roles[playerIndex];
    const myName = state.players[playerIndex];

    const evilIdxs = state.roles
      .map((r, i) => ({r, i}))
      .filter(x => x.r.team === 'Evil')
      .map(x => x.i);

    const evilNames = evilIdxs.map(i => state.players[i]);
    const evilRoles = evilIdxs.map(i => state.roles[i].name);
    const oberonInGame = state.roles.some(r => r.name === 'Oberon');
    const mordredInGame = state.roles.some(r => r.name === 'Mordred');

    // Helper: "known evil to evil (except Oberon)".
    function evilKnownToEvil(i) {
      const role = state.roles[i].name;
      return role !== 'Oberon';
    }

    // Merlin sees evil except Mordred
    if (me.name === 'Merlin') {
      const seen = evilIdxs.filter(i => state.roles[i].name !== 'Mordred').map(i => state.players[i]);
      const mordredNote = mordredInGame
        ? 'There is a Mordred in this game and you do NOT know him/her.'
        : 'There is NOT any Mordred in this game.';
      return `You know Evils:\n ${seen.length ? seen.join('\n') : 'Nobody'}\n\n${mordredNote}`;
    }

    // Percival sees Merlin + Morgana as candidates
    if (me.name === 'Percival') {
      const candidates = [];
      state.roles.forEach((r, i) => {
        if (r.name === 'Merlin' || r.name === 'Morgana') candidates.push(state.players[i]);
      });
      return `Possible Merlin/Morgana:\n ${candidates.length ? candidates.join('\nOR\n ') : 'None (Merlin/Morgana not in game?)'}`;
    }

    // Evil (except Oberon) sees other evil (except Oberon)
    if (me.team === 'Evil') {
      if (me.name === 'Oberon') {
        return `You are Evil, but you do not know the other Evil players.`;
      }
      const knownEvil = evilIdxs
        .filter(i => i !== playerIndex)
        .filter(i => evilKnownToEvil(i))
        .map(i => state.players[i]);
      const oberonNote = (state.nPlayers >= 10 && oberonInGame) ? '\nNote: Oberon is in this game; you do NOT know him/her.' : '';
      return `Other Evils known to you:\n ${knownEvil.length ? knownEvil.join('\n') : 'None'}\n${oberonNote}`;
    }

    return `You are Good. Try to pass quests and identify Evil.`;
  }

  function currentQuestTeamSize() {
    const sizes = teamSizes[state.nPlayers] || [2,3,3,4,4];
    return sizes[state.currentQuest] || sizes[sizes.length - 1];
  }

  function pickNewLeader(options = {}) {
    const { exclude = [], avoidUsedAcross = false } = options;
    if (!state.players.length) return null;
    const excludeSet = new Set(exclude);
    let candidates = state.players.map((_, i) => i).filter(i => !excludeSet.has(i));

    if (avoidUsedAcross) {
      const usedSet = new Set(state.usedApprovedLeaders);
      const filtered = candidates.filter(i => !usedSet.has(i));
      if (filtered.length) candidates = filtered;
    }

    if (!candidates.length) {
      candidates = state.players.map((_, i) => i).filter(i => !excludeSet.has(i));
    }
    if (!candidates.length) return null;
    return candidates[Math.floor(Math.random() * candidates.length)];
  }

  function updateQuestStatusText(customText) {
    if (customText) {
      statusText.textContent = customText;
      return;
    }
    if (state.ended) return;
    let detail = '';
    if (state.questPhase === 'proposal') detail = `Proposal ${state.proposalAttempt} of 5`;
    if (state.questPhase === 'vote') detail = `Proposal ${state.proposalAttempt} — awaiting vote`;
    if (state.questPhase === 'mission') detail = `Mission in progress`;
    statusText.textContent = `Quest ${state.currentQuest+1} — ${detail || 'not decided'}`;
  }

  function renderTeamPicker() {
    const teamSize = currentQuestTeamSize();
    teamPicker.innerHTML = '';
    state.players.forEach((p, idx) => {
      const label = document.createElement('label');
      label.className = 'checkbox';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.value = String(idx);
      cb.checked = state.currentProposal.includes(idx);
      cb.addEventListener('change', () => {
        const selected = getSelectedProposalTeam();
        teamPickHint.textContent = `Selected ${selected.length}/${teamSize} players`;
      });
      label.appendChild(cb);
      label.appendChild(document.createTextNode(p));
      teamPicker.appendChild(label);
    });
    const selected = getSelectedProposalTeam();
    teamPickHint.textContent = `Selected ${selected.length}/${teamSize} players`;
  }

  function getSelectedProposalTeam() {
    const inputs = teamPicker.querySelectorAll('input[type="checkbox"]');
    const selected = [];
    inputs.forEach(input => {
      if (input.checked) selected.push(Number(input.value));
    });
    return selected;
  }

  function renderProposalState() {
    if (!state.started || state.players.length === 0 || state.ended) {
      proposalArea.classList.add('hidden');
      voteArea.classList.add('hidden');
      missionArea.classList.add('hidden');
      missionRevealAction.classList.add('hidden');
      return;
    }

    const teamSize = currentQuestTeamSize();
    const leaderName = (state.currentLeaderIndex !== null) ? state.players[state.currentLeaderIndex] : '—';
    proposalStatus.innerHTML = `Quest ${state.currentQuest+1}: Proposal ${state.proposalAttempt} of 5` +
      `<span class="leaderLine">Leader: ${leaderName}</span>`;
    teamSizeText.textContent = `Select ${teamSize} players for this quest.`;

    const questResolved = state.questResults[state.currentQuest] !== null;
    
    const showProposal = state.questPhase === 'proposal' && !questResolved;
    const showVote = state.questPhase === 'vote' && !questResolved;
    const showMission = state.questPhase === 'mission' && !questResolved;
    const showRevealAction = state.questPhase === 'mission' && state.missionRevealReady && !questResolved;

    if (showProposal) {
      proposalArea.classList.remove('hidden');
      renderTeamPicker();
    } else {
      proposalArea.classList.add('hidden');
    }

    if (showVote) {
      voteArea.classList.remove('hidden');
      const names = state.currentProposal.map(i => state.players[i]);
      voteSummary.innerHTML = `<div><b>Proposal ${state.proposalAttempt}</b> for Quest ${state.currentQuest+1}</div><div>${names.join(', ')}</div>`;
    } else {
      voteArea.classList.add('hidden');
    }

    if (showMission) {
      missionArea.classList.remove('hidden');
      renderMissionStep();
    } else {
      missionArea.classList.add('hidden');
    }

    if (showRevealAction) {
      missionRevealAction.classList.remove('hidden');
    } else {
      missionRevealAction.classList.add('hidden');
    }

    updateQuestStatusText();
  }

  function resetQuestFlowForCurrentQuest() {
    state.proposalAttempt = 1;
    state.currentProposal = [];
    state.missionStepIndex = 0;
    state.missionFailCount = 0;
    state.missionCards = [];
    state.missionRevealReady = false;
    state.questPhase = 'proposal';
    state.currentQuestLeaders = [];
    const leader = pickNewLeader({ avoidUsedAcross: true });
    state.currentLeaderIndex = leader;
    if (leader !== null) state.currentQuestLeaders.push(leader);
    missionRevealArea.classList.add('hidden');
    missionRevealContainer.innerHTML = '';
    missionRevealNote.textContent = '';
    renderProposalState();
  }

  function handleSubmitProposal() {
    if (state.ended || state.questPhase !== 'proposal') return;
    const team = getSelectedProposalTeam();
    const needed = currentQuestTeamSize();
    if (team.length !== needed) {
      alert(`Select exactly ${needed} players for this quest.`);
      return;
    }
    state.currentProposal = team;
    state.questPhase = 'vote';
    renderProposalState();
  }

  function handleVoteResult(approved) {
    if (state.ended || state.questPhase !== 'vote') return;
    if (!approved) {
      state.proposalAttempt += 1;
      if (state.proposalAttempt > 5) {
        resolveQuestResult(false, `Quest ${state.currentQuest+1} failed: 5 proposals rejected.`);
        return;
      }
      state.currentProposal = [];
      state.questPhase = 'proposal';
      const newLeader = pickNewLeader({ exclude: state.currentQuestLeaders, avoidUsedAcross: true });
      state.currentLeaderIndex = newLeader;
      if (newLeader !== null) {
        state.currentQuestLeaders.push(newLeader);
      }
      renderProposalState();
      return;
    }
    // Approved proposal: record leader as used across quests
    if (state.currentLeaderIndex !== null && !state.usedApprovedLeaders.includes(state.currentLeaderIndex)) {
      state.usedApprovedLeaders.push(state.currentLeaderIndex);
    }
    state.questPhase = 'mission';
    state.missionStepIndex = 0;
    state.missionFailCount = 0;
    state.missionCards = [];
    state.missionRevealReady = false;
    renderProposalState();
  }

  function renderMissionStep() {
    if (state.ended || state.questPhase !== 'mission') return;
    missionRevealArea.classList.add('hidden');
    missionRevealContainer.innerHTML = '';
    missionRevealNote.textContent = '';
    missionRevealAction.classList.add('hidden');
    const team = state.currentProposal;
    const idx = state.missionStepIndex;
    const needs2 = questNeedsTwoFails(state.nPlayers, state.currentQuest);
    missionFailRule.textContent = needs2 ? 'Quest fails only if 2 FAIL cards are played.' : 'Quest fails if any FAIL card is played.';
    if (idx >= team.length) return;
    const playerName = state.players[team[idx]];
    missionPrompt.innerHTML = `Hand phone to ${playerName}<br><br>(team member ${idx+1} of ${team.length}).<br><br>Choose PASS or FAIL secretly.`;
  }

  function handleMissionCard(isPass) {
    if (state.ended || state.questPhase !== 'mission') return;
    state.missionCards.push(isPass);
    if (!isPass) state.missionFailCount += 1;
    state.missionStepIndex += 1;
    if (state.missionStepIndex >= state.currentProposal.length) {
      const needs2 = questNeedsTwoFails(state.nPlayers, state.currentQuest);
      const success = needs2 ? state.missionFailCount < 2 : state.missionFailCount === 0;
      state.missionRevealReady = true;
      missionFailRule.textContent = '';
      missionPrompt.textContent = 'All cards submitted. Tap "Show the results" to reveal.';
      missionRevealAction.classList.remove('hidden');
      btnCardPass.disabled = true;
      btnCardFail.disabled = true;
      return;
    }
    renderMissionStep();
  }

  function resolveQuestResult(resultSuccess, reasonText) {
    state.questResults[state.currentQuest] = resultSuccess;
    let next = state.questResults.findIndex(x => x === null);
    if (next === -1) next = 4;
    state.currentQuest = next;
    renderQuestGrid();
    updateScoreAndStatus();
    if (!state.ended) {
      if (reasonText) updateQuestStatusText(reasonText);
      resetQuestFlowForCurrentQuest();
      disableQuestButtons(false);
    } else if (reasonText) {
      statusText.textContent = reasonText;
    }
    renderProposalState();
  }

  function renderQuestGrid() {
    questGrid.innerHTML = '';
    const n = state.nPlayers;
    const sizes = teamSizes[n] || [2,3,3,4,4];

    for (let q = 0; q < 5; q++) {
      const res = state.questResults[q];
      const needs2 = questNeedsTwoFails(n, q);
      const box = document.createElement('div');
      box.className = 'questBox';
      if (res === true) box.classList.add('good');
      if (res === false) box.classList.add('evil');

      const title = document.createElement('div');
      title.style.fontWeight = '700';
      title.textContent = `Quest ${q+1}`;

      const sub = document.createElement('div');
      sub.className = 'muted';
      sub.textContent = `Team: ${sizes[q]} • ${needs2 ? '2 fails to fail' : '1 fail fails'}`;

      const status = document.createElement('div');
      status.style.marginTop = '6px';
      status.style.fontWeight = '700';
      status.textContent = (res === null) ? (q === state.currentQuest ? 'Current' : 'Pending')
        : (res ? 'SUCCESS' : 'FAIL');

      box.appendChild(title);
      box.appendChild(sub);
      box.appendChild(status);
      questGrid.appendChild(box);
    }
  }

  function updateScoreAndStatus() {
    state.goodScore = state.questResults.filter(x => x === true).length;
    state.evilScore = state.questResults.filter(x => x === false).length;

    scoreText.textContent = `Good ${state.goodScore} • Evil ${state.evilScore}`;

    if (!state.ended) {
      updateQuestStatusText();
    }

    // End conditions
    if (state.goodScore >= 3) {
      state.ended = true;
      statusText.textContent = `Good has 3 successes`;
      endgameArea.classList.remove('hidden');
      endgameText.textContent = `Good wins… for now`;
      endgameSub.textContent = `If Assassin is in the game, they may guess Merlin.`;

      if (state.roles.some(r => r.name === 'Assassin')) {
        assassinArea.classList.remove('hidden');
        populateAssassinPick();
      } else {
        assassinArea.classList.add('hidden');
        endgameSub.textContent = `No Assassin role included. Final result: Good wins.`;
      }
      disableQuestButtons(true);
    }

    if (state.evilScore >= 3) {
      state.ended = true;
      statusText.textContent = `Evil has 3 fails`;
      endgameArea.classList.remove('hidden');
      endgameText.textContent = `Evil wins`;
      endgameSub.textContent = `Final result: Evil wins.`;
      assassinArea.classList.add('hidden');
      disableQuestButtons(true);
    }
    setHostControlsVisibility();
  }

  function disableQuestButtons(disabled) {
    [btnSubmitProposal, btnVoteApprove, btnVoteReject, btnCardPass, btnCardFail].forEach(btn => {
      btn.disabled = disabled;
    });
    btnShowReveal.disabled = disabled;
    const inputs = teamPicker.querySelectorAll('input[type="checkbox"]');
    inputs.forEach(cb => cb.disabled = disabled);
  }

  function showMissionReveal(success, needs2) {
    disableQuestButtons(true);
    missionRevealAction.classList.add('hidden');
    missionRevealArea.classList.remove('hidden');
    missionRevealContainer.innerHTML = '';
    const cards = shuffle([...state.missionCards]);
    missionRevealTitle.textContent = `Quest ${state.currentQuest+1} results:`;
    missionRevealNote.textContent = 'Cards revealed in random order for suspense.';

    cards.forEach((isPass, idx) => {
      const card = document.createElement('div');
      card.className = 'revealCard';
      card.textContent = isPass ? 'PASS' : 'FAIL';
      missionRevealContainer.appendChild(card);
      setTimeout(() => {
        card.classList.add(isPass ? 'pass' : 'fail', 'show');
      }, 300 + idx * 650);
    });

    const revealDuration = 1000 + cards.length * 1000 + 2000;
    setTimeout(() => {
      const reasonText = needs2
        ? (success ? 'Quest succeeded (fewer than 2 FAIL cards).' : 'Quest failed (2+ FAIL cards).')
        : (success ? 'Quest succeeded (no FAIL cards).' : 'Quest failed (at least one FAIL card).');
      resolveQuestResult(success, reasonText);
    }, revealDuration);
  }

  function setHostControlsVisibility() {
    const assassinInGame = state.roles.some(r => r.name === 'Assassin');
    const assassinPhaseActive = assassinInGame && state.goodScore >= 3 && !state.assassinResolved;
    if (state.ended && !assassinPhaseActive) {
      btnShowAllRoles.classList.remove('hidden');
    } else {
      btnShowAllRoles.classList.add('hidden');
      allRoles.classList.add('hidden');
      allRoles.innerHTML = '';
    }
  }

  function populateAssassinPick() {
    assassinPick.innerHTML = '';
    state.players.forEach((p, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = p;
      assassinPick.appendChild(opt);
    });
  }

  // ---------- Flow ----------
  function resetAll() {
    state.started = false;
    state.players = [];
    state.roles = [];
    state.revealIndex = 0;
    state.questResults = [null,null,null,null,null];
    state.currentQuest = 0;
    state.goodScore = 0;
    state.evilScore = 0;
    state.ended = false;
    state.assassinResolved = false;
    state.proposalAttempt = 1;
    state.currentProposal = [];
    state.missionStepIndex = 0;
    state.missionFailCount = 0;
    state.missionCards = [];
    state.questPhase = 'proposal';
    state.currentLeaderIndex = null;
    state.usedApprovedLeaders = [];
    state.currentQuestLeaders = [];

    setupCard.classList.remove('hidden');
    revealCard.classList.add('hidden');
    gameCard.classList.add('hidden');

    roleDisplay.classList.add('hidden');
    btnShowRole.classList.remove('hidden');
    btnHideRole.classList.add('hidden');
    btnNextPlayer.disabled = true;

    delete roleMerlin.dataset.manual;
    delete rolePercival.dataset.manual;
    delete roleMorgana.dataset.manual;
    delete roleAssassin.dataset.manual;
    delete roleOberon.dataset.manual;
    delete roleMordred.dataset.manual;
    allRoles.classList.add('hidden');
    allRoles.innerHTML = '';

    endgameArea.classList.add('hidden');
    assassinArea.classList.add('hidden');
    disableQuestButtons(false);
    setHostControlsVisibility();

    updateSetupHint();
    missionRevealArea.classList.add('hidden');
    missionRevealContainer.innerHTML = '';
    missionRevealNote.textContent = '';
    renderProposalState();
  }

  function startGame() {
    const n = clampPlayers(Number(numPlayersEl.value));
    state.nPlayers = n;

    const flags = getSelectedRoleFlags();
    const evilN = evilCountFor(n);
    if (flags.evilSpecialCount() > evilN) {
      alert(`Too many evil special roles selected. Evil players for ${n} is ${evilN}. Uncheck some evil roles.`);
      return;
    }

    state.players = parsePlayers(n);
    state.roles = buildRoles(n, flags);
    state.started = true;
    resetQuestFlowForCurrentQuest();
    setHostControlsVisibility();

    // Reveal UI
    setupCard.classList.add('hidden');
    revealCard.classList.remove('hidden');
    gameCard.classList.add('hidden');

    state.revealIndex = 0;
    showRevealStep();
  }

  function showRevealStep() {
    const i = state.revealIndex;
    revealStep.textContent = `Hand phone to: ${state.players[i]} (Player ${i+1} of ${state.nPlayers})`;
    roleDisplay.classList.add('hidden');
    btnShowRole.classList.remove('hidden');
    btnHideRole.classList.add('hidden');
    btnNextPlayer.disabled = true;
  }

  function showRole() {
    const i = state.revealIndex;
    const r = state.roles[i];
    roleName.textContent = r.name;
    roleTeam.textContent = `Team: ${r.team}`;
    const knowledge = buildKnowledgeText(i).replaceAll('\n', '<br>');
    roleInfo.innerHTML = `<div style="margin-bottom:8px;">${r.blurb}</div><div style="opacity:.95">${knowledge}</div>`;
    roleDisplay.classList.remove('hidden');
    btnShowRole.classList.add('hidden');
    btnHideRole.classList.remove('hidden');
    btnNextPlayer.disabled = false;
  }

  function hideRole() {
    roleDisplay.classList.add('hidden');
    btnShowRole.classList.remove('hidden');
    btnHideRole.classList.add('hidden');
    btnNextPlayer.disabled = true;
  }

  function nextPlayer() {
    if (state.revealIndex < state.nPlayers - 1) {
      state.revealIndex += 1;
      showRevealStep();
    } else {
      // Done revealing
      revealCard.classList.add('hidden');
      gameCard.classList.remove('hidden');

      resetQuestFlowForCurrentQuest();
      renderQuestGrid();
      updateScoreAndStatus();
    }
  }

  function resolveAssassination() {
    if (state.assassinResolved) return;

    const pickIdx = Number(assassinPick.value);
    const pickedRole = state.roles[pickIdx];

    state.assassinResolved = true;

    if (pickedRole.name === 'Merlin') {
      endgameText.textContent = `Assassin found Merlin — Evil wins`;
      endgameSub.textContent = `${state.players[pickIdx]} was Merlin.`;
    } else {
      endgameText.textContent = `Assassin missed — Good wins`;
      endgameSub.textContent = `${state.players[pickIdx]} was ${pickedRole.name}.`;
    }
    assassinArea.classList.add('hidden');
    setHostControlsVisibility();
  }

  function toggleAllRoles() {
    if (!state.ended) return; // Host view only after game ends
    if (allRoles.classList.contains('hidden')) {
      allRoles.classList.remove('hidden');
      const lines = state.players.map((p, i) => {
        const r = state.roles[i];
        return `<div class="pill">${p}: <b>${r.name}</b> (${r.team})</div>`;
      }).join('');
      allRoles.innerHTML = lines;
    } else {
      allRoles.classList.add('hidden');
      allRoles.innerHTML = '';
    }
  }

  // ---------- Events ----------
  numPlayersEl.addEventListener('input', updateSetupHint);
  [roleMerlin, rolePercival, roleAssassin, roleMorgana, roleOberon, roleMordred].forEach(el => el.addEventListener('change', () => {
    el.dataset.manual = 'true';
    if (el === rolePercival || el === roleMorgana) {
      const paired = el === rolePercival ? roleMorgana : rolePercival;
      paired.dataset.manual = 'true';
      paired.checked = el.checked;
    }
    updateSetupHint();
  }));

  btnStart.addEventListener('click', startGame);
  btnResetAll.addEventListener('click', resetAll);

  btnShowRole.addEventListener('click', showRole);
  btnHideRole.addEventListener('click', hideRole);
  btnNextPlayer.addEventListener('click', nextPlayer);

  btnSubmitProposal.addEventListener('click', handleSubmitProposal);
  btnVoteApprove.addEventListener('click', () => handleVoteResult(true));
  btnVoteReject.addEventListener('click', () => handleVoteResult(false));
  btnCardPass.addEventListener('click', () => handleMissionCard(true));
  btnCardFail.addEventListener('click', () => handleMissionCard(false));
  btnShowReveal.addEventListener('click', () => {
    const needs2 = questNeedsTwoFails(state.nPlayers, state.currentQuest);
    const success = needs2 ? state.missionFailCount < 2 : state.missionFailCount === 0;
    showMissionReveal(success, needs2);
  });

  btnAssassinConfirm.addEventListener('click', resolveAssassination);

  btnShowAllRoles.addEventListener('click', toggleAllRoles);

  // init
  updateSetupHint();
</script>
</body>
</html>
